//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a Chugin boilerplate, generated by chuginate!
//-----------------------------------------------------------------------------

// this should align with the correct versions of these ChucK files
#include "chuck_dl.h"
#include "chuck_def.h"
#include "chuck_instr.h"
#include "chuck_vm.h"

// general includes
#include <stdio.h>
#include <limits.h>

// STL includes
#include <iostream>
#include <string>
using namespace std;

#include "JuceHeader.h"
#include "SamplerAudioProcessor.h"

// declaration of chugin constructor
CK_DLL_CTOR(sampler_ctor);
// declaration of chugin desctructor
CK_DLL_DTOR(sampler_dtor);

// functions
CK_DLL_MFUN(sampler_read);
CK_DLL_MFUN(sampler_getnumparameters);
CK_DLL_MFUN(sampler_getparametername);
CK_DLL_MFUN(sampler_getparameter);
CK_DLL_MFUN(sampler_setparameter);
CK_DLL_MFUN(sampler_noteon);
CK_DLL_MFUN(sampler_noteoff);
CK_DLL_MFUN(sampler_loadPreset);

// multi-channel audio synthesis tick function
CK_DLL_TICKF(sampler_tickstereoin);

// this is a special offset reserved for Chugin internal data
t_CKINT sampler_data_offset = 0;


//-----------------------------------------------------------------------------
// name: class SamplerChugin
// desc: SamplerChugin instrument implementation (via JUCE)
//-----------------------------------------------------------------------------
class SamplerChugin
{
public:
    // constructor
    SamplerChugin(t_CKFLOAT srate)
    {
        sampler.prepareToPlay(srate, 512);
        sampler.setNonRealtime(false);
        sampler.reset();

        // sample rate
        m_srate = srate;

        // output is stereo
        m_chans = 2;

        myBuffer = new juce::AudioBuffer<float>(m_chans, 512);
    }

    ~SamplerChugin()
    {
        sampler.releaseResources();
    
        if (myBuffer) {
            delete myBuffer;
        }

        delete myChuckString;
    }

    // for Chugins extending UGen
    void tickstereoin(SAMPLE* in, SAMPLE* out, int nframes);
    
    bool read(const string& filename);

    bool noteOn(int note, float velocity);
    bool noteOff(int note, float velocity);

    int getNumParameters();
    Chuck_String* getParameterName(int index);
    float getParameter(int index);
    bool setParameter(int index, float v);

private:
    // data
    t_CKINT m_chans;

    // sample rate
    t_CKFLOAT m_srate;

protected:
    
    SamplerAudioProcessor sampler;

    std::string myPluginPath = "";

    juce::AudioSampleBuffer* myBuffer;
    juce::MidiBuffer myMidiBuffer;
    Chuck_String* myChuckString = new Chuck_String("");

};

void SamplerChugin::tickstereoin(SAMPLE* in, SAMPLE* out, int nframes)
{

    myBuffer->setSize(2, nframes, false, true, false);
    // in contains alternating left and right channels.
    for (int chan = 0; chan < 2; chan++) {
        auto chanPtr = myBuffer->getWritePointer(chan);
        for (int i = 0; i < nframes; i++)
        {
            *chanPtr++ = in[i * 2 + chan];
        }
    }

    sampler.processBlock(*myBuffer, myMidiBuffer);

    // copy from buffer to output.
    // out needs to receive alternating left/right channels.
    for (int chan = 0; chan < 2; chan++) {
        auto chanPtr = myBuffer->getReadPointer(chan);
        for (int i = 0; i < nframes; i++)
        {
            out[chan + 2 * i] = *chanPtr++;
        }
    }

    myMidiBuffer.clear();
}

bool SamplerChugin::read(const string& path) {
    return sampler.setSample(path.c_str());
}


bool SamplerChugin::noteOn(int noteNumber, float velocity) {
    using namespace juce;
    
    // Get the note on midiBuffer.
    MidiMessage onMessage = MidiMessage::noteOn(1, noteNumber, velocity);
    onMessage.setTimeStamp(0);
    myMidiBuffer.addEvent(onMessage, onMessage.getTimeStamp());

    return true;
}

bool SamplerChugin::noteOff(int noteNumber, float velocity) {
    using namespace juce;

    MidiMessage offMessage = MidiMessage::noteOff(1, noteNumber, velocity);
    offMessage.setTimeStamp(0);
    myMidiBuffer.addEvent(offMessage, offMessage.getTimeStamp());
    
    return true;
}

int SamplerChugin::getNumParameters() {
    return sampler.getNumParameters();
}

Chuck_String* SamplerChugin::getParameterName(int index) {
    try
    {
        myChuckString->set(sampler.getParameterName(index).toStdString());
        return myChuckString;
    }
    catch (const std::exception&)
    {
        myChuckString->set("");
        return myChuckString;
    }
}

float SamplerChugin::getParameter(int index) {

    try
    {
        return sampler.getParameter(index);
    }
    catch (const std::exception&)
    {
        return 0.;
    }
}

bool SamplerChugin::setParameter(int index, float v) {
    try
    {
        sampler.setParameterNotifyingHost(index, v);
        return true;
    }
    catch (const std::exception&)
    {
        return false;
    }
}


//-----------------------------------------------------------------------------
// query function: chuck calls this when loading the Chugin
//-----------------------------------------------------------------------------
CK_DLL_QUERY( Sampler )
{
    // hmm, don't change this...
    QUERY->setname(QUERY, "Sampler");

    // begin the class definition
    // can change the second argument to extend a different ChucK class
    QUERY->begin_class(QUERY, "Sampler", "UGen");

    // register the constructor (probably no need to change)
    QUERY->add_ctor(QUERY, sampler_ctor);
    // register the destructor (probably no need to change)
    QUERY->add_dtor(QUERY, sampler_dtor);

    // 2, 2 to do stereo in and stereo out
    QUERY->add_ugen_funcf(QUERY, sampler_tickstereoin, NULL, 2, 2);

    QUERY->add_mfun(QUERY, sampler_read, "int", "read");
    QUERY->add_arg(QUERY, "string", "filename");

    QUERY->add_mfun(QUERY, sampler_getnumparameters, "int", "getNumParameters");

    QUERY->add_mfun(QUERY, sampler_getparametername, "string", "getParameterName");
    QUERY->add_arg(QUERY, "int", "index");

    QUERY->add_mfun(QUERY, sampler_getparameter, "float", "getParameter");
    QUERY->add_arg(QUERY, "int", "index");

    QUERY->add_mfun(QUERY, sampler_setparameter, "int", "setParameter");
    QUERY->add_arg(QUERY, "int", "index");
    QUERY->add_arg(QUERY, "float", "value");

    QUERY->add_mfun(QUERY, sampler_noteon, "int", "noteOn");
    QUERY->add_arg(QUERY, "int", "noteNumber");
    QUERY->add_arg(QUERY, "float", "velocity");

    QUERY->add_mfun(QUERY, sampler_noteoff, "int", "noteOff");
    QUERY->add_arg(QUERY, "int", "noteNumber");
    QUERY->add_arg(QUERY, "float", "velocity");

    // this reserves a variable in the ChucK internal class to store
    // referene to the c++ class we defined above
    sampler_data_offset = QUERY->add_mvar(QUERY, "int", "@b_data", false);

    // end the class definition
    // IMPORTANT: this MUST be called!
    QUERY->end_class(QUERY);

    // wasn't that a breeze?
    return TRUE;
}

// implementation for the constructor
CK_DLL_CTOR(sampler_ctor)
{
    // get the offset where we'll store our internal c++ class pointer
    OBJ_MEMBER_INT(SELF, sampler_data_offset) = 0;

    // instantiate our internal c++ class representation
    SamplerChugin * b_obj = new SamplerChugin(API->vm->get_srate(API, SHRED));

    // store the pointer in the ChucK object member
    OBJ_MEMBER_INT(SELF, sampler_data_offset) = (t_CKINT) b_obj;
}

// implementation for the destructor
CK_DLL_DTOR(sampler_dtor)
{
    // get our c++ class pointer
    SamplerChugin * b_obj = (SamplerChugin *) OBJ_MEMBER_INT(SELF, sampler_data_offset);
    // check it
    if( b_obj )
    {
        // clean up
        delete b_obj;
        OBJ_MEMBER_INT(SELF, sampler_data_offset) = 0;
        b_obj = NULL;
    }
}

// implementation for tick function
CK_DLL_TICKF(sampler_tickstereoin)
{
    // get our c++ class pointer
    SamplerChugin* b = (SamplerChugin*)OBJ_MEMBER_INT(SELF, sampler_data_offset);

    // invoke our tick function; store in the magical out variable
    if (b) b->tickstereoin(in, out, nframes);

    // yes
    return TRUE;
}

CK_DLL_MFUN(sampler_read)
{
    string filename = GET_NEXT_STRING_SAFE(ARGS);

    SamplerChugin* b = (SamplerChugin*)OBJ_MEMBER_INT(SELF, sampler_data_offset);
    
    RETURN->v_int = b->read(filename.c_str());
}

CK_DLL_MFUN(sampler_getnumparameters)
{
    SamplerChugin* b = (SamplerChugin*)OBJ_MEMBER_INT(SELF, sampler_data_offset);

    RETURN->v_int = b->getNumParameters();
}

CK_DLL_MFUN(sampler_getparametername)
{
    t_CKINT index = GET_NEXT_INT(ARGS);

    SamplerChugin* b = (SamplerChugin*)OBJ_MEMBER_INT(SELF, sampler_data_offset);

    RETURN->v_string = b->getParameterName(index);
}

CK_DLL_MFUN(sampler_getparameter)
{
    t_CKINT index = GET_NEXT_INT(ARGS);

    SamplerChugin* b = (SamplerChugin*)OBJ_MEMBER_INT(SELF, sampler_data_offset);

    RETURN->v_float = b->getParameter(index);
}

CK_DLL_MFUN(sampler_setparameter)
{
    t_CKINT index = GET_NEXT_INT(ARGS);
    t_CKFLOAT val = GET_NEXT_FLOAT(ARGS);

    SamplerChugin* b = (SamplerChugin*)OBJ_MEMBER_INT(SELF, sampler_data_offset);

    RETURN->v_int = b->setParameter(index, val);
}

CK_DLL_MFUN(sampler_noteon)
{
    t_CKINT noteNumber = GET_NEXT_INT(ARGS);
    t_CKFLOAT velocity = GET_NEXT_FLOAT(ARGS);

    SamplerChugin* b = (SamplerChugin*)OBJ_MEMBER_INT(SELF, sampler_data_offset);

    RETURN->v_int = b->noteOn(noteNumber, velocity);
}

CK_DLL_MFUN(sampler_noteoff)
{
    t_CKINT noteNumber = GET_NEXT_INT(ARGS);
    t_CKFLOAT velocity = GET_NEXT_FLOAT(ARGS);

    SamplerChugin* b = (SamplerChugin*)OBJ_MEMBER_INT(SELF, sampler_data_offset);

    RETURN->v_int = b->noteOff(noteNumber, velocity);
}
